input {
    http_poller {
        urls => {
            spy_quote => {
                method => "get"
                url => "https://finnhub.io/api/v1/quote?symbol=SPY&token=${FINNHUB_API_KEY}"
                headers => {
                    Accept => "application/json"
                }
            }
            qqq_quote => {
                method => "get"
                url => "https://finnhub.io/api/v1/quote?symbol=QQQ&token=${FINNHUB_API_KEY}"
                headers => {
                    Accept => "application/json"
                }
            }
            iwm_quote => {
                method => "get"
                url => "https://finnhub.io/api/v1/quote?symbol=IWM&token=${FINNHUB_API_KEY}"
                headers => {
                    Accept => "application/json"
                }
            }
        }
        schedule => { every => "30s" }
        request_timeout => 30
        socket_timeout => 30
        connect_timeout => 10
        automatic_retries => 3
        metadata_target => "http_poller_metadata"
    }
}

filter {
    if [http_poller_metadata][name] == "spy_quote" {
        mutate {
            add_field => { "symbol" => "SPY" }
        }
    } else if [http_poller_metadata][name] == "qqq_quote" {
        mutate {
            add_field => { "symbol" => "QQQ" }
        }
    } else if [http_poller_metadata][name] == "iwm_quote" {
        mutate {
            add_field => { "symbol" => "IWM" }
        }
    }
    if [c] and [c] != 0 {
        mutate {
            add_field => { 
                "timestamp" => "%{@timestamp}"
                "data_source" => "finnhub"
                "data_type" => "real_time_quote"
            }
        }
        mutate {
            rename => { 
                "c" => "current_price"
                "d" => "change"
                "dp" => "percent_change"
                "h" => "high"
                "l" => "low"
                "o" => "open"
                "pc" => "previous_close"
            }
        }
        mutate {
            convert => {
                "current_price" => "float"
                "change" => "float"
                "percent_change" => "float"
                "high" => "float"
                "low" => "float"
                "open" => "float"
                "previous_close" => "float"
            }
        }
        ruby {
            code => "
                high = event.get('high').to_f
                low = event.get('low').to_f
                open_price = event.get('open').to_f
                if high > 0 and low > 0 and open_price > 0
                    intraday_range = high - low
                    intraday_volatility = (intraday_range / open_price) * 100
                    event.set('intraday_volatility', intraday_volatility.round(4))
                    event.set('intraday_range', intraday_range.round(2))
                end
                event.set('doc_id', event.get('symbol') + '_' + Time.now.to_i.to_s)
            "
        }
        mutate {
            remove_field => [ 
                "http_poller_metadata", 
                "@version",
                "host",
                "headers"
            ]
        }
        mutate {
            add_tag => ["processed", "valid_quote"]
        }
    } else {
        mutate {
            add_tag => ["invalid_response"]
            add_field => { "error_reason" => "Empty or zero price data" }
        }
        ruby {
            code => "
                puts '[ERROR] Invalid response for symbol: ' + event.get('symbol').to_s
                puts '[ERROR] Response data: ' + event.to_hash.to_s
            "
        }
    }
}

output {
    if "valid_quote" in [tags] {
        kafka {
            bootstrap_servers => "kafka:29092"
            topic_id => "financial_prices"
            message_key => "%{symbol}"
            codec => json
            acks => "1"
            retries => 3
            batch_size => 100
            linger_ms => 100
            compression_type => "snappy"
        }
    }
    if "invalid_response" in [tags] {
        stdout { 
            codec => rubydebug {
                metadata => true
            }
        }
    }
    if "processed" in [tags] {
        file {
            path => "/usr/share/logstash/output_logs/etf_quotes_%{+YYYY.MM.dd}.log"
            codec => json_lines
        }
    }
}
