input {
    http_poller {
        urls => {
            spy_quote => {
                method => "get"
                url => "https://finnhub.io/api/v1/quote?symbol=SPY&token=${FINNHUB_API_KEY}"
                headers => {
                    Accept => "application/json"
                }
            }
            qqq_quote => {
                method => "get"
                url => "https://finnhub.io/api/v1/quote?symbol=QQQ&token=${FINNHUB_API_KEY}"
                headers => {
                    Accept => "application/json"
                }
            }
            iwm_quote => {
                method => "get"
                url => "https://finnhub.io/api/v1/quote?symbol=IWM&token=${FINNHUB_API_KEY}"
                headers => {
                    Accept => "application/json"
                }
            }
        }
        schedule => { every => "30s" }
        request_timeout => 30
        socket_timeout => 30
        connect_timeout => 10
        automatic_retries => 3
        metadata_target => "http_poller_metadata"
        
    }
}

filter {
    if [http_poller_metadata][name] == "spy_quote" {
        mutate {
            add_field => { "symbol" => "SPY" }
        }
    } else if [http_poller_metadata][name] == "qqq_quote" {
        mutate {
            add_field => { "symbol" => "QQQ" }
        }
    } else if [http_poller_metadata][name] == "iwm_quote" {
        mutate {
            add_field => { "symbol" => "IWM" }
        }
    }
    if [c] and [c] != 0 {
        mutate {
            add_field => { 
                "timestamp" => "%{@timestamp}"
                "data_source" => "finnhub"
                "data_type" => "real_time_quote"
            }
        }
        mutate {
            rename => { 
                "c" => "current_price"
                "d" => "change"
                "dp" => "percent_change"
                "h" => "high"
                "l" => "low"
                "o" => "open"
                "pc" => "previous_close"
            }
        }
        mutate {
            convert => {
                "current_price" => "float"
                "change" => "float"
                "percent_change" => "float"
                "high" => "float"
                "low" => "float"
                "open" => "float"
                "previous_close" => "float"
            }
        }
        ruby {
            code => "
                high = event.get('high')
                low = event.get('low')
                open_price = event.get('open')
                if high.is_a?(Numeric) && low.is_a?(Numeric) && open_price.is_a?(Numeric) && 
                     high > 0 && low > 0 && open_price > 0
                    begin
                        intraday_range = high - low
                        intraday_volatility = (intraday_range / open_price) * 100
                        event.set('intraday_volatility', intraday_volatility.round(4))
                        event.set('intraday_range', intraday_range.round(2))
                    rescue => e
                        event.set('intraday_volatility', 0.0)
                        event.set('intraday_range', 0.0)
                    end
                else
                    event.set('intraday_volatility', 0.0)
                    event.set('intraday_range', 0.0)
                end
                symbol = event.get('symbol') || 'UNKNOWN'
                timestamp = Time.now.to_i
                event.set('doc_id', symbol + '_' + timestamp.to_s)
            "
        }
        mutate {
            remove_field => [ 
                "http_poller_metadata", 
                "@version",
                "host",
                "headers"
            ]
        }
        mutate {
            add_tag => ["processed", "valid_quote"]
        }
    } else {
        mutate {
            add_tag => ["invalid_response"]
            add_field => { "error_reason" => "Empty or zero price data" }
        }
        ruby {
            code => "
                puts '[ERROR] Invalid response for symbol: ' + event.get('symbol').to_s
                puts '[ERROR] Response data: ' + event.to_hash.to_s
            "
        }
    }
}

output {
    if "valid_quote" in [tags] {
        kafka {
            bootstrap_servers => "kafka:29092"
            topic_id => "financial_prices"
            message_key => "%{symbol}"
            codec => json
            acks => "1"
            retries => 3
            batch_size => 100
            linger_ms => 100
            compression_type => "snappy"
        }
    }
    if "invalid_response" in [tags] {
        stdout { 
            codec => rubydebug {
                metadata => true
            }
        }
    }
    if "processed" in [tags] {
        file {
            path => "/usr/share/logstash/output_logs/etf_quotes_%{+YYYY.MM.dd}.log"
            codec => json_lines
        }
    }
}
