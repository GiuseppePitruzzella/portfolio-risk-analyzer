# Configurazione Logstash DEFINITIVA - Fix symbol issue
# File: config/logstash.conf

input {
  http_poller {
    urls => {
      spy_quote => {
        method => get
        url => "https://finnhub.io/api/v1/quote?symbol=SPY&token=${FINNHUB_API_KEY}"
        headers => {
          Accept => "application/json"
        }
      }
      qqq_quote => {
        method => get
        url => "https://finnhub.io/api/v1/quote?symbol=QQQ&token=${FINNHUB_API_KEY}"
        headers => {
          Accept => "application/json"
        }
      }
      iwm_quote => {
        method => get
        url => "https://finnhub.io/api/v1/quote?symbol=IWM&token=${FINNHUB_API_KEY}"
        headers => {
          Accept => "application/json"
        }
      }
    }
    
    schedule => { every => "60s" }
    request_timeout => 30
    
    # CORREZIONE: Usa sintassi standard per metadata
    metadata_target => "http_poller_metadata"
    
    # add_tag => ["finnhub_api"]
  }
}

filter {
  # METODO 1: Accesso diretto ai metadata (sintassi corretta)
  if [http_poller_metadata] {
    
    # Estrai il name e usalo per determinare il symbol
    ruby {
      code => "
        metadata = event.get('http_poller_metadata')
        if metadata && metadata['name']
          request_name = metadata['name']
          
          case request_name
          when 'spy_quote'
            event.set('symbol', 'SPY')
            event.set('debug_source', 'metadata_name')
          when 'qqq_quote'
            event.set('symbol', 'QQQ')
            event.set('debug_source', 'metadata_name')
          when 'iwm_quote'
            event.set('symbol', 'IWM')
            event.set('debug_source', 'metadata_name')
          else
            event.set('debug_error', 'unknown_request_name: ' + request_name.to_s)
          end
        else
          event.set('debug_error', 'no_metadata_or_name')
        end
      "
    }
  }
  
  # METODO 2: Fallback - Estrai dall'URL se metadata fallisce
  if ![symbol] and [http_poller_metadata] {
    ruby {
      code => "
        metadata = event.get('http_poller_metadata')
        if metadata && metadata['url']
          url = metadata['url']
          
          if url.include?('symbol=SPY')
            event.set('symbol', 'SPY')
            event.set('debug_source', 'url_extraction')
          elsif url.include?('symbol=QQQ')
            event.set('symbol', 'QQQ')
            event.set('debug_source', 'url_extraction')
          elsif url.include?('symbol=IWM')
            event.set('symbol', 'IWM')
            event.set('debug_source', 'url_extraction')
          else
            event.set('debug_error', 'url_no_symbol_found: ' + url.to_s)
          end
        else
          event.set('debug_error', 'no_url_in_metadata')
        end
      "
    }
  }
  
  # METODO 3: Fallback estremo - Pattern matching su tutto il messaggio
  if ![symbol] {
    ruby {
      code => "
        # Come ultima risorsa, cerca pattern nell'intero evento
        event_str = event.to_hash.to_s
        
        if event_str.include?('SPY')
          event.set('symbol', 'SPY')
          event.set('debug_source', 'pattern_matching')
        elsif event_str.include?('QQQ')
          event.set('symbol', 'QQQ')
          event.set('debug_source', 'pattern_matching')
        elsif event_str.include?('IWM')
          event.set('symbol', 'IWM')
          event.set('debug_source', 'pattern_matching')
        else
          event.set('debug_error', 'no_symbol_pattern_found')
        end
      "
    }
  }
  
  # Processa solo se abbiamo symbol E dati validi
  if [symbol] and [c] and [c] != 0 {
    
    # Aggiungi informazioni base
    mutate {
      add_field => {
        "timestamp" => "%{@timestamp}"
        "data_source" => "finnhub"
        "data_type" => "real_time_quote"
      }
      add_tag => ["has_symbol"]
    }
    
    # Rinomina campi API
    mutate {
      rename => {
        "c" => "current_price"
        "d" => "change"
        "dp" => "percent_change"
        "h" => "high"
        "l" => "low"
        "o" => "open"
        "pc" => "previous_close"
      }
    }
    
    # Converti a numeri
    mutate {
      convert => {
        "current_price" => "float"
        "change" => "float"
        "percent_change" => "float"
        "high" => "float"
        "low" => "float"
        "open" => "float"
        "previous_close" => "float"
      }
    }
    
    # Calcoli semplici (senza Ruby complesso per evitare errori)
    if [high] and [low] and [open] {
      ruby {
        code => "
          begin
            high = event.get('high').to_f
            low = event.get('low').to_f
            open_val = event.get('open').to_f
            
            if high > 0 && low > 0 && open_val > 0
              range_val = high - low
              volatility = (range_val / open_val) * 100
              event.set('intraday_range', range_val.round(2))
              event.set('intraday_volatility', volatility.round(4))
            end
          rescue
            # Ignora errori nei calcoli
          end
        "
      }
    }
    
    # ID univoco
    mutate {
      add_field => { "doc_id" => "%{symbol}_%{+UNIX_TIMESTAMP}" }
    }
    
    # Cleanup
    mutate {
      remove_field => [ "http_poller_metadata", "@version", "host" ]
      add_tag => ["processed", "valid_quote"]
    }
    
  } else {
    # Debug per messaggi problematici
    mutate {
      add_tag => ["debug_failed"]
    }
    
    if ![symbol] {
      mutate {
        add_field => { "error_type" => "no_symbol" }
      }
    }
    
    if ![c] or [c] == 0 {
      mutate {
        add_field => { "error_type" => "no_price_data" }
      }
    }
  }
}

output {
  # Debug: SEMPRE mostra tutto
  stdout {
    codec => rubydebug
  }
  
  # Kafka: solo messaggi processati con symbol
  if "valid_quote" in [tags] {
    kafka {
      bootstrap_servers => "kafka:29092"
      topic_id => "financial_prices"
      codec => json
    }
  }
  
  # Debug file per analisi problemi
  if "debug_failed" in [tags] {
    file {
      path => "/usr/share/logstash/output_logs/debug_failed.log"
      codec => json_lines
    }
  }
}